================================================================================
SOLUCION: Error 405 Not Allowed en Produccion
================================================================================

ANALISIS DEL PROBLEMA
================================================================================

Errores Identificados:

1. Error 405 Not Allowed de nginx
   <html>
   <head><title>405 Not Allowed</title></head>
   <body>
   <center><h1>405 Not Allowed</h1></center>
   <hr><center>nginx/1.29.3</center>
   </body>
   </html>

2. VITE_API_URL no definida (problema del frontend, pero relacionado)

3. Pagina insegura (http://) - advertencia de seguridad

CAUSA RAIZ
================================================================================

El error 405 Not Allowed de nginx indica que:
- nginx esta bloqueando las peticiones POST antes de que lleguen al backend
- La configuracion de nginx no esta permitiendo metodos HTTP correctos
- O nginx no esta redirigiendo correctamente las peticiones al backend

El backend Spring Boot esta funcionando correctamente, el problema es la configuracion de nginx.

SOLUCION: Configuracion de nginx
================================================================================

Configuracion Correcta de nginx

Crea o actualiza tu archivo de configuracion de nginx (normalmente en /etc/nginx/sites-available/tu-sitio o /etc/nginx/nginx.conf):

server {
    listen 80;
    server_name 148.230.87.167;

    # Frontend (Vite)
    location / {
        root /ruta/a/tu/frontend/dist;
        try_files $uri $uri/ /index.html;
        index index.html;
    }

    # Backend API (Spring Boot)
    location /api {
        # Permitir todos los metodos HTTP necesarios
        if ($request_method = 'OPTIONS') {
            add_header 'Access-Control-Allow-Origin' 'http://148.230.87.167:3000';
            add_header 'Access-Control-Allow-Methods' 'GET, POST, PUT, DELETE, OPTIONS, PATCH';
            add_header 'Access-Control-Allow-Headers' 'DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range,Authorization';
            add_header 'Access-Control-Allow-Credentials' 'true';
            add_header 'Access-Control-Max-Age' 1728000;
            add_header 'Content-Type' 'text/plain; charset=utf-8';
            add_header 'Content-Length' 0;
            return 204;
        }

        # Proxy al backend Spring Boot
        proxy_pass http://localhost:8080;
        proxy_http_version 1.1;
        
        # Headers necesarios
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        
        # Timeouts
        proxy_connect_timeout 60s;
        proxy_send_timeout 60s;
        proxy_read_timeout 60s;
        
        # Buffer settings
        proxy_buffering off;
        proxy_request_buffering off;
    }

    # Health check del backend
    location /actuator {
        proxy_pass http://localhost:8080;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    }
}

PUNTOS CLAVE DE LA CONFIGURACION
================================================================================

1. Permitir Metodos HTTP

CORRECTO: Permitir todos los metodos necesarios
location /api {
    # No usar limit_except aqui, permite todos los metodos
    proxy_pass http://localhost:8080;
}

INCORRECTO (causa error 405):
location /api {
    limit_except GET {
        deny all;  # Esto bloquea POST, PUT, DELETE
    }
    proxy_pass http://localhost:8080;
}

2. Manejar OPTIONS (CORS Preflight)

if ($request_method = 'OPTIONS') {
    add_header 'Access-Control-Allow-Origin' 'http://148.230.87.167:3000';
    add_header 'Access-Control-Allow-Methods' 'GET, POST, PUT, DELETE, OPTIONS, PATCH';
    add_header 'Access-Control-Allow-Headers' '*';
    add_header 'Access-Control-Allow-Credentials' 'true';
    return 204;
}

3. Proxy Correcto al Backend

proxy_pass http://localhost:8080;  # Puerto donde corre Spring Boot

Verificar que Spring Boot este corriendo en el puerto 8080:
netstat -tulpn | grep 8080
# o
ss -tulpn | grep 8080

PASOS PARA APLICAR LA SOLUCION
================================================================================

1. Crear/Editar Configuracion de nginx

sudo nano /etc/nginx/sites-available/casaglass

Pegar la configuracion de arriba y ajustar:
- server_name: Tu dominio o IP
- root: Ruta a tu frontend compilado
- proxy_pass: Puerto donde corre Spring Boot (probablemente 8080)

2. Crear Enlace Simbolico (si no existe)

sudo ln -s /etc/nginx/sites-available/casaglass /etc/nginx/sites-enabled/

3. Verificar Configuracion

sudo nginx -t

Deberia mostrar:
nginx: the configuration file /etc/nginx/nginx.conf syntax is ok
nginx: configuration file /etc/nginx/nginx.conf test is successful

4. Recargar nginx

sudo systemctl reload nginx
# o
sudo service nginx reload

5. Verificar que Funciona

# Probar endpoint de login
curl -X POST http://148.230.87.167/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{"username":"test","password":"test"}'

SEGURIDAD: HTTPS (Recomendado)
================================================================================

Advertencia Actual:
Campos de contrasena presentes en una pagina insegura (http://)

Solucion: Configurar HTTPS

1. Obtener certificado SSL (Let's Encrypt):
sudo apt install certbot python3-certbot-nginx
sudo certbot --nginx -d tu-dominio.com

2. Configuracion nginx con HTTPS:
server {
    listen 80;
    server_name 148.230.87.167;
    return 301 https://$server_name$request_uri;
}

server {
    listen 443 ssl http2;
    server_name 148.230.87.167;

    ssl_certificate /etc/letsencrypt/live/tu-dominio.com/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/tu-dominio.com/privkey.pem;

    # ... resto de la configuracion igual ...
}

VERIFICACION DEL BACKEND
================================================================================

El Backend Esta Correctamente Configurado:

Endpoint existe: POST /api/auth/login en AuthController.java
CORS configurado: Permite http://148.230.87.167:* en CorsConfig.java
Metodos permitidos: GET, POST, PUT, DELETE, OPTIONS, PATCH

Verificar que el Backend Este Corriendo:

# Verificar proceso de Spring Boot
ps aux | grep java

# Verificar puerto 8080
netstat -tulpn | grep 8080

# Probar directamente (sin nginx)
curl -X POST http://localhost:8080/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{"username":"test","password":"test"}'

Si esto funciona directamente, el problema es 100% nginx.

NOTA SOBRE VITE_API_URL
================================================================================

El error VITE_API_URL no esta definida es del frontend. Debes crear .env.production:

# .env.production (en el proyecto frontend)
VITE_API_URL=http://148.230.87.167:8080/api

O mejor aun, usar la misma URL que nginx:
VITE_API_URL=http://148.230.87.167/api

Importante: Despues de cambiar .env.production, debes recompilar el frontend:
npm run build

CHECKLIST DE VERIFICACION
================================================================================

- nginx configurado para permitir POST, PUT, DELETE en /api
- nginx redirige /api a http://localhost:8080
- Spring Boot corriendo en puerto 8080
- Configuracion de nginx verificada con nginx -t
- nginx recargado con systemctl reload nginx
- Frontend tiene .env.production con VITE_API_URL
- Frontend recompilado despues de cambiar .env.production
- Endpoint /api/auth/login responde correctamente

RESUMEN
================================================================================

Problema: nginx esta bloqueando peticiones POST (error 405)

Solucion: 
1. Configurar nginx para permitir todos los metodos HTTP en /api
2. Redirigir /api a http://localhost:8080 (backend Spring Boot)
3. Configurar CORS en nginx para OPTIONS requests
4. Crear .env.production en el frontend con VITE_API_URL

El backend NO necesita cambios, solo la configuracion de nginx.



